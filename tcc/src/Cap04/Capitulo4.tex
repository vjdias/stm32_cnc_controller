\chapter{Resultados e Discussão}\label{cap:resultados}

Este capítulo apresenta os resultados obtidos durante a validação do
controlador CNC, destacando o desempenho dos serviços críticos, a análise
do pipeline SPI e a interação com o cliente Raspberry Pi.

\section{Desempenho dos serviços principais}

A medição do gerador de passos configurado no TIM6 demonstrou a
estabilidade do DDA em \SI{50}{\kilo\hertz}, com variação máxima de
\SI{0.4}{\percent} entre ciclos consecutivos. O pulso STEP mínimo de
\SI{1}{\micro\second} atende aos requisitos dos drivers TMC5160. O laço
PID executado no TIM7 manteve jitter inferior a \SI{3}{\micro\second}
segundo o tempo instrumentado na ISR. Essas medições confirmam que as
interrupções de alta prioridade permanecem isoladas das rotinas de
comunicação e registro de eventos.

Os serviços de homing, checagem de limites e monitoramento de falhas
foram executados dentro do orçamento do laço de \SI{1}{\milli\second},
utilizando leituras incrementais dos encoders. Quando a fila de logs
cresceu acima de 75\%, o serviço de console reduziu a taxa de mensagens
automatizando a proteção contra estouros.

\section{Análise do pipeline SPI}

A captura do tráfego SPI revelou que cada comando completo envolve um
handshake seguido de até dois polls adicionais do mestre até que a
resposta esteja pronta. Durante o primeiro ciclo, o firmware congela o
DMA para permitir que \texttt{app\_poll} processe o pedido e preencha a resposta.
Caso o serviço conclua a operação antes do tempo limite interno, o
segundo poll já retorna o quadro \texttt{0xAB ... 0x54}; do contrário, o DMA é
reiniciado com padrão \texttt{0xA5}, e somente o terceiro ciclo entrega a
mensagem final. A análise confirmou que ajustes no parâmetro
\texttt{APP\_SPI\_RESTART\_DEFER\_MAX} alteram a quantidade de iterações tolerada
antes do fallback, permitindo balancear latência e robustez.

Experimentos adicionais reduziram a cópia de memória ao promover o
payload diretamente para o buffer ativo do DMA, diminuindo o tempo médio
entre polls em \SI{18}{\percent}. Entretanto, essa otimização exige
tratamento cuidadoso de coerência entre buffers para evitar corrupção de
dados quando múltiplos serviços respondem simultaneamente.

\section{Integração com a Raspberry Pi}

O cliente \texttt{cnc\_spi\_client.py} executando na Raspberry Pi validou o
comportamento determinístico do protocolo. O script detecta automaticamente
quando a resposta não contém um frame válido e reenvia o poll após um
intervalo configurável. Durante os testes, \texttt{--tries=4} e
\texttt{--settle-delay=0.75 ms} mostraram-se suficientes para
acomodar comandos de homing e leitura de estado. Além disso, a
sincronização com a fila de logs via USART1 permitiu correlacionar eventos
de firmware com os pacotes SPI, fornecendo rastreabilidade durante o
comissionamento.

Os resultados confirmam que a divisão de responsabilidades entre STM32 e
Raspberry Pi atende às metas de determinismo, sem sacrificar a
flexibilidade de integração com interfaces gráficas ou scripts de
automação.

\section{Fluxo do comando \texttt{cnc\text{-}cli}}

O comando \texttt{cnc\text{-}cli} executa uma sequência declarativa de ações
em um arquivo JSON (patches do TMC5160, ajustes de PID e movimentos). A Figura~\ref{fig:cnc-seq-flow}
resume o fluxo principal, incluindo validações, enfileiramento no STM32 e
monitoramento de falhas do TMC5160.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[
    node distance=8mm and 10mm,
    every node/.style={font=\small},
    box/.style={
      draw=blue!80, 
      fill=blue!10, 
      rounded corners, 
      align=center, 
      inner sep=4pt, 
      minimum width=3.8cm
    },
    io/.style={
      draw=blue!80, 
      fill=blue!10, 
      trapezium, 
      trapezium left angle=70, 
      trapezium right angle=110, 
      align=center, 
      minimum height=8mm
    },
    decision/.style={
      draw=blue!80, 
      fill=blue!10, 
      diamond, 
      aspect=1.8, 
      inner sep=1pt, align=center
    },
    terminator/.style={draw=blue!80, fill=blue!10, ellipse, align=center, inner sep=3pt, minimum width=2.8cm},
    arrow/.style={->, >=Stealth, line width=0.9pt, blue!60, rounded corners=2pt, shorten <=2pt, shorten >=2pt}
  ]
    \node[io] (start) {Ler application.cfg\\e arquivo de sequência};
    \node[box, below=of start] (validate) {Validar limites (PID, vel, TMC)\\conforme cfg.limits};
    \node[decision, below=of validate] (ok) {Válido?};
    \node[box, right=22mm of ok] (abort) {Abortar execução\\Log de motivos};
    \node[box, below=of ok] (connect) {Abrir SPI\\STM32 (dev 0)};
    \node[box, below=of connect] (ledblink) {LED pisca (execução)};
    \node[box, below=of ledblink] (steps) {Iterar passos da sequência:};

    \node[box, below left=of steps, xshift=-5mm] (tmc) {tmc\{:\} aplica patch\\(TOFF/HSTRT/HEND/TBL/\\MRES/INTPOL/DEDGE/\ldots)};
    \node[box, below right=of steps, xshift=5mm] (pid) {pid\{:\} atualizar ganhos\\default (x,y,z)};
    
    \node[box, below=32mm of steps] (move) {move\{:\} enfileirar REQ\_MOVE\_QUEUE\_ADD\\(pos/vel/dir, PID atual)\\frameId interno incremental};
    \node[box, below=of move] (startmv) {REQ\_START\_MOVE};
    \node[box, below=of startmv] (monitor) {Loop de monitoramento:\\QueueStatus + TMC DRV\_STATUS/GSTAT};
    
    \node[decision, below left=of monitor, xshift=12mm] (tmcerr) {TMC erro?\\(OT/OTPW/DRV\_ERR)};
    \node[decision, below right=of monitor, xshift=-12mm] (done) {STM32 concluiu?};
    
    \node[box, below=of tmcerr] (tmcstop) {Segurança: TOFF=0, IHOLD/IRUN=0\\LED aceso (falha)};
    \node[box, below=of done] (finish) {LED apagado\\TOFF=0 (pós-execução)};
    \node[terminator, below=of tmcstop] (endfail) {Encerrar (falha)};
    \node[terminator, below=of finish] (endok) {Encerrar (sucesso)};

    \draw[arrow] (start) -- (validate);
    \draw[arrow] (validate) -- (ok);
    \draw[arrow] (ok.east) to[out=0, in=180] node[midway, above]{não} (abort.west);
    \draw[arrow] (ok.south) to[out=-90, in=90] node[midway, right]{sim} (connect.north);
    \draw[arrow] (connect) -- (ledblink);
    \draw[arrow] (ledblink) -- (steps);
    
    \draw[arrow] (steps.south) to[out=-90, in=90] (tmc.north);
    \draw[arrow] (steps.south) to[out=-90, in=90] (pid.north);
    \draw[arrow] (tmc.south) to[out=-90, in=135] (move.north);
    \draw[arrow] (pid.south) to[out=-90, in=45] (move.north);

    \draw[arrow] (move) -- (startmv);
    \draw[arrow] (startmv) -- (monitor);
    
    \draw[arrow] (monitor.south) to[out=-90, in=90] (tmcerr.north);
    \draw[arrow] (monitor.south) to[out=-90, in=90] (done.north);
    
    \draw[arrow] (tmcerr.south) -- node[midway, left]{sim} (tmcstop.north);
    \draw[arrow] (done.south) -- node[midway, right]{sim} (finish.north);

    % Saídas finais e loop "não concluiu"
    \draw[arrow] (tmcstop) -- (endfail);
    \draw[arrow] (finish) -- (endok);
    \draw[arrow] (done.west) to[out=180, in=180, looseness=1.25] node[midway, below]{não} (monitor.west);

  \end{tikzpicture}
  \caption{Fluxo do comando \texttt{cnc\text{-}cli}: validação, aplicação de patches TMC, enfileiramento de movimentos no STM32, monitoramento e estados do LED.}
  \label{fig:cnc-cli-flow}
\end{figure}

\subsection*{Descrição do fluxo}
\begin{enumerate}
  \item \textbf{Leitura de arquivos}: o cliente carrega o \texttt{application.cfg} (conexões, limites e presets) e o JSON de sequência (lista de passos \texttt{steps}).
  \item \textbf{Validação} (no Raspberry): cada item da sequência é verificado contra os limites do \texttt{cfg.limits}––faixas de PID, teto de velocidade e parâmetros do TMC5160. Qualquer violação aborta a execução, com mensagens registradas em log (\texttt{raspberry\_spi/run\_logs/}).
  \item \textbf{Conexão SPI com STM32}: abre \texttt{/dev/spidev\{bus\}.\{dev\}} do microcontrolador para enviar comandos do protocolo CNC (MOVE\_QUEUE\_ADD/STATUS/START/END).
  \item \textbf{Sinalização por LED (STM32)}: o LED passa a piscar durante a execução; em falha fica aceso; no sucesso, é apagado ao final.
  \item \textbf{Iteração de passos}:
    \begin{itemize}
      \item \texttt{tmc\{...\}}: aplica patches no CHOPCONF/PWMCONF/registradores correlatos (\texttt{toff}, \texttt{hstrt}/\texttt{hend}, \texttt{tbl}, \texttt{dedge}, \texttt{microsteps}/\texttt{interpolate}, \texttt{globalscaler}, \texttt{ihold}/\texttt{irun}/\texttt{ihold\_delay}, \texttt{tpowerdown}).
      \item \texttt{pid\{...\}}: atualiza os ganhos padrão por eixo para os próximos movimentos.
      \item \texttt{move\{pos, vel, dir\}}: enfileira segmentos no STM32 via \texttt{REQ\_MOVE\_QUEUE\_ADD} com \textit{frameId} gerado internamente e, após o último, envia \texttt{REQ\_START\_MOVE}.
    \end{itemize}
  \item \textbf{Monitoramento}: o cliente consulta periodicamente o \texttt{MOVE\_QUEUE\_STATUS} para acompanhar o progresso (percentuais por eixo). Em paralelo, lê \texttt{GSTAT/DRV\_STATUS} do TMC5160 para detectar falhas críticas.
  \item \textbf{Tratamento de falhas (TMC)}: se houver \emph{overtemp}/\emph{OTPW} ou \emph{driver\_error}, aplica "segurança" em todos os drivers (\texttt{TOFF=0}, \texttt{IHOLD/IRUN=0}), mantém o LED do STM32 aceso e encerra a execução.
  \item \textbf{Término normal}: ao concluir todos os movimentos, o cliente aplica \texttt{TOFF=0} (pós-execução), apaga o LED do STM32 e finaliza o run.
\end{enumerate}
